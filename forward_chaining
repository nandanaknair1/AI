def infer(facts, rules):
    inferred = set([f.strip() for f in facts])
    while True:
        added = False
        for rule in rules:
            if "=>" not in rule:
                continue
            left, right = rule.split("=>", 1)
            left_parts = [p.strip() for p in left.split("^") if p.strip()]
            right = right.strip()

            # Try to find a set of bindings that satisfy all left_parts
            # We'll try to find one matching fact per left_part (naive)
            def match_atom_to_fact(atom, fact, bindings):
                # atom like pred(A,X) where A may be variable or constant
                try:
                    pred, args = atom.split("(", 1)
                    args = args[:-1].split(",")
                    pred = pred.strip()
                except:
                    return None
                if not fact.startswith(pred + "("):
                    return None
                fact_args = fact[fact.find("(")+1:-1].split(",")
                fact_args = [fa.strip() for fa in fact_args]
                if len(fact_args) != len(args):
                    return None
                new_bind = dict(bindings)
                for a, f in zip([a.strip() for a in args], fact_args):
                    if a == "":
                        return None
                    # variable if starts with uppercase
                    if a[0].isupper():
                        if a in new_bind and new_bind[a] != f:
                            return None
                        new_bind[a] = f
                    else:
                        # constant: must match exactly
                        if a != f:
                            return None
                return new_bind

            # We need to search over inferred facts to match all left_parts.
            possible_bindings = [dict()]  # start with empty binding
            success = False
            for part in left_parts:
                new_poss = []
                for b in possible_bindings:
                    for fact in inferred:
                        mb = match_atom_to_fact(part, fact, b)
                        if mb is not None:
                            new_poss.append(mb)
                possible_bindings = new_poss
                if not possible_bindings:
                    break
            if not possible_bindings:
                continue

            # For each successful binding, generate the head with substituted constants
            for binding in possible_bindings:
                try:
                    hpred, hargs = right.split("(", 1)
                    hargs = hargs[:-1].split(",")
                    hpred = hpred.strip()
                except:
                    continue
                instantiated_args = []
                for a in [a.strip() for a in hargs]:
                    if a == "":
                        instantiated_args.append(a)
                    elif a[0].isupper():
                        instantiated_args.append(binding.get(a, a))
                    else:
                        instantiated_args.append(a)
                result = f"{hpred}(" + ",".join(instantiated_args) + ")"
                if result not in inferred:
                    print(f"Inferred: {result}")
                    inferred.add(result)
                    added = True

        if not added:
            break
    return inferred


# ---------- MAIN ----------
if __name__ == "__main__":
    print("=== Forward Chaining in First Order Logic ===\n")

    # Input facts
    n = int(input("Enter number of facts: "))
    facts = [input(f"Fact {i+1}: ").strip() for i in range(n)]

    # Input rules
    m = int(input("\nEnter number of rules: "))
    rules = [input(f"Rule {i+1} (use ^ for AND, => for implies): ").strip() for i in range(m)]

    # Input query
    query = input("\nEnter the query to prove: ").strip()

    print("\nInitial Facts:")
    for f in facts:
        print(" ", f)

    print("\n--- Forward Chaining Steps ---")
    inferred = infer(facts, rules)

    print("\nAll inferred facts:")
    for f in sorted(inferred):
        print(" ", f)

    if query in inferred:
        print(f"\nQuery '{query}' is proved using Forward Chaining!")
    else:
        print(f"\nQuery {query}' cannot be proved.")
